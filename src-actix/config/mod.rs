pub mod models;

use std::path::PathBuf;
use std::sync::{Arc, RwLock};
use log::{info, warn};
use models::AppConfig;

pub type SharedConfig = Arc<RwLock<AppConfig>>;

/// Returns the path to the config file.
/// On Windows: %APPDATA%/playarr/config.toml
/// On Linux/macOS: ~/.config/playarr/config.toml
pub fn config_path() -> PathBuf {
    let base = dirs::config_dir().unwrap_or_else(|| PathBuf::from("."));
    base.join("playarr").join("config.toml")
}

/// Load config from disk, or return default if not found.
pub fn load_config() -> AppConfig {
    let path = config_path();
    if path.exists() {
        match std::fs::read_to_string(&path) {
            Ok(contents) => match toml::from_str::<AppConfig>(&contents) {
                Ok(config) => {
                    info!("Loaded config from {}", path.display());
                    return config;
                }
                Err(e) => {
                    warn!("Failed to parse config at {}: {}", path.display(), e);
                }
            },
            Err(e) => {
                warn!("Failed to read config at {}: {}", path.display(), e);
            }
        }
    } else {
        info!("No config found at {}, using defaults", path.display());
    }
    AppConfig::default()
}

/// Save config to disk. Skipped during tests to avoid corrupting real config.
pub fn save_config(config: &AppConfig) -> anyhow::Result<()> {
    if cfg!(test) {
        return Ok(());
    }
    let path = config_path();
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    let contents = toml::to_string_pretty(config)?;
    std::fs::write(&path, contents)?;
    info!("Saved config to {}", path.display());
    Ok(())
}

/// Create a shared config instance.
/// If the loaded config has no client_id (upgraded from old version), one is
/// auto-generated by serde default. We detect that and persist it so the same
/// client_id is used on every subsequent launch. We also clear any stale token
/// since it was bound to the old (missing/hardcoded) client identifier.
pub fn init_shared_config() -> SharedConfig {
    let path = config_path();
    let needs_client_id = if path.exists() {
        // Check if the on-disk config already has a client_id
        std::fs::read_to_string(&path)
            .ok()
            .and_then(|s| toml::from_str::<toml::Value>(&s).ok())
            .map(|v| v.get("plex").and_then(|p| p.get("client_id")).is_none())
            .unwrap_or(false)
    } else {
        true // New install, will need to persist the generated id
    };

    let mut config = load_config();

    if needs_client_id {
        // The token (if any) was created with a different client identifier,
        // so it will be rejected by Plex. Clear it to force re-authentication.
        if !config.plex.token.is_empty() {
            warn!("Clearing stale Plex token â€” client_id was missing. Please sign in again.");
            config.plex.token.clear();
        }
        if let Err(e) = save_config(&config) {
            warn!("Failed to persist new client_id: {}", e);
        }
    }

    Arc::new(RwLock::new(config))
}
